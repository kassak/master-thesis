%-*-coding: utf-8-*-
\everymath{\displaystyle}

\chapter{Решение задачи определения района поиска предложенным методом}
\section{Нахождение функции кратчайшего расстояния}
\subsection{Обработка исходных картографических данных}
Картографические данные поступают на вход алгоритма в
виде ломанных и многоугольников, для каждой из которых указан тип местности
для этого объекта (лес, дорога, озеро...). По этим данным строится триангуляция
Делоне (Constrained Delaunay Triangulation). Ее ребрам и треугольникам
соответствуют атрибуты -- множество типов местности через которые они проходят.

Эта триангуляция обладает тем свойством, что все внутренние точки каждого ее
треугольника имеют одинаковый тип местности, откуда следует, что внутри
треугольников кратчайшие расстояние измеряется по прямой. То же верно и
для ребер триангуляции.

Стоит обратить внимание на то, что тип местности для ребра треугольника
не обязательно совпадает с типом местности самого треугольника. Достаточно
рассмотреть что произойдет с дорогой проходящей через лес. Треугольники
инцидентные дороге будут иметь тип местности "лес", тогда как ребра
порожденные дорогой будут иметь тип местности "дорога".

\subsection{Сужение функции кратчайшего расстояния}
Функция кратчайшего расстояния $d(P)$ определена на плоскости, но
задание такой сложной функции на плоскости не тривиальная задача.
Поэтому удобно будет рассматривать эту функцию на линейных объектах.
В чем нам поможет следующее утверждение.

{\prop\label{sh_path}
$\forall T: T$ -- не содержит точек исходного района,
$\forall P \in T, d(P) = \min_{Q \in \delta T} \{d(Q) + dist(Q, P)\}$}
\begin{proof}
Рассмотрим кратчайший путь в $P$. Так как путь начинается вне $T$,
а заканчивается внутри, то существует $Q \in \delta T$ -- точка
где кратчайший путь пересекает границу $T$.

Покажем, что в этой точке достигается минимум. предположим обратное.
Рассмотрим другую точку $R \in \delta T$, в которой достигается минимум.
Получаем $d(P) = d(Q) + dist(Q, P) > d(R) + dist(R, P) = d(P)$ -- противоречие.
\end{proof}

В итоге получается, что кратчайшее расстояние до внутренних точек треугольника,
полностью определяется кратчайшим расстоянием до его границ.

То есть задача нахождения кратчайшего расстояния до всех точек плоскости
может быть разбита на две части:
\begin{enumerate}
\item Нахождение кратчайших расстояний до границ некоторого подразбиения плоскости
\item Нахождение кратчайших расстояний внутри областей подразбиения, как
$d(P) = \min_{Q \in \delta T} \{d(Q) + dist(Q, P)\}$
\end{enumerate}

Теперь рассмотрим триангуляцию, получившуюся в результате обработки исходных данных.
Далее используем функцию $lerp(S, t) = tS_0 + (1-t)S_1$ -- интерполяция точки отрезка.
Назовем $d_S(t) = d(lerp(S, t))$ сужением функции $d(P)$ на отрезок $S$.
Если найти кратчайшие расстояния до ее ребер, то кратчайшее расстояние до
его внутренних точек будет
$d(P) = \min_{S \in \{S^1, S^2, S^3\} } \min_{t \in [0; 1] } \{d(lerp(S, t)) + len(lerp(S, t), P)\}$,
где $len(P, Q)$ -- длина отрезка $PQ$, а $S^1, S^2, S^3$ -- стороны треугольника.

\subsection{Структуры данных}
Для возможности учета линейных объектов ребра триангуляции порождают
два типа объектов (далее просто ребра):
\begin{itemize}
\item Ребра треугольника -- ребра граней триангуляции.
Тип местности ребра соответствует типу местности грани.
\item Промежуточные ребра -- ребра триангуляции.
Тип местности соответствует типу местности ребра триангуляции.
\end{itemize}
Каждое ребро триангуляции, кроме находящихся на границе, порождает
два ребра треугольника (по одному на каждый смежный треугольник)
и одно промежуточное ребро.

Триангуляция хранится в реберном списке с двойной связностью
(РСДС, DCEL) -- структуре данных позволяющей удобно оперировать
планарным подразбиением плоскости.
\todo{expand DCEL}

Каждому ребру присваивается уникальный индекс, который далее
будет использоваться для получения его атрибутов.
Эти индексы хранятся в атрибутах РСДС:
\begin{itemize}
\item В атрибутах грани в виде троек $\langle I^1, I^2, I^3 \rangle$ --
индексы ребер треугольника.
\item В атрибутах ребер  в виде пар $\langle I, D \rangle$, где $I$ --
индекс промежуточного ребра, а $D$ -- показывает сонаправлено или
противонаправлено промежуточное ребро с ребром РСДС. Второй
параметр необходим, так как одному ребру триангуляции соответствуют
два противонаправленных ребра РСДС. Направление промежуточного пебра
выбирается произвольно.
\end{itemize}

Каждому ребру соответствуют атрибуты:
\begin{itemize}
\item тип местности ребра;
\item текущее приближение $d_S(t)$.
\end{itemize}

Чтобы далее последовательно приближать $d_S(t)$, нужно ввести связность между
ребрами получившейся структуры.
\begin{itemize}
\item С ребра треугольника можно перейти на:
  \begin{itemize}
  \item другое ребро этого же треугольника;
  \item смежное ему промежуточное ребро.
  \end{itemize}
\item С промежуточного ребра можно перейти на:
  \begin{itemize}
  \item промежуточные ребра, инцидентные его началу и концу;
  \item смежное ему ребро треугольника.
  \end{itemize}
\end{itemize}

Такая связность позволяет учитывать множество аспектов движения
объекта поиска. Например ему можно запретить пересекать реки,
можно разрешить, но ввести штраф, равный времени пересечения реки.
Для этого вводятся две величины:
\begin{description}
\item[Коэффициент проходимости] величина характеризующая сложность прохождения
одного метра. В нашем случае это $\frac{1}{v}$, где $v$ -- скорость движения
по данному типу местности. Задается для ребра.
\item[Штраф] величина, добавляющаяся к функции кратчайшего расстояния при
переходе с одного ребра на другое. Определяется по типу местности ребер,
между которыми осуществляется переход. Для случая перехода с промежуточного
ребра на промежуточное, влияют все ребра инцидентные вершине, через которую
осуществляется переход. Последнее позволяет проверить, пересекается ли при
этом река, пересекает ли реку дорога (свидетельство наличия моста).
\end{description}


\subsection{Алгоритм}
Суть алгоритма заключается в последовательном определении сужения функции
кратчайшего расстояния для каждого ребра триангуляции.

Назовем $\displaystyle d'_S(t) = \min_{t' \in [0; 1]}\{d_{S'}(t') + dist(lerp(S', t'), lerp(S, t))\}$
обновлением функции $d_S(t)$ ребра $S$ от ребра $S'$. Эта функция
соответствует длинам текущего приближения кратчайших путей до ребра $S$,
проходящих через ребро $S'$.

В приоритетной очереди находятся события. Событие -- это пара
$\langle S, d'_S(t) \rangle$. Приоритет события -- $\displaystyle\min_{t \in [0; 1]}\{d'_S(t)\}$.

\begin{description}
\item[Инициализация]\hfill \\
\begin{enumerate}
\item Для каждого ребра $S$, $d_S(t) \gets \infty$.
\item Для каждого ребра $S: S$ -- внутри исходного района, $d_S(t) \gets 0$.
\item Для каждой вершины $V$ исходного района, для каждого инцидентного ей
ребра $S$:
  \begin{enumerate}
  \item $d'_S(t) \gets len(S)wt'$, где $len(s)$ -- длина ребра $S$,
    $w$ -- его коэффициент проходимости, $t' = t$ или $1 - t$, в зависимости от
    того $V$ начало или конец $S$ соответственно.
  \item Добавить событие $\langle S, d'_S(t) \rangle$ в очередь.
  \end{enumerate}
\end{enumerate}

\item[Шаг алгоритма]\hfill \\
\begin{enumerate}
\item Из очереди извлекается событие $\langle S, d'_S(t) \rangle$ с наименьшим приоритетом.
\item Если $\forall x \in [0; 1]: d_S(t) \leq d'_S(t)$, то событие игнорируется
\item $d_S \gets lower\_envelope(d_S, d'_S)$, где $lower\_envelope$ --
нижняя огибающая, поточечный минимум функций.
\item Для каждого ребра $S'$, связанного с $S$:
  \begin{enumerate}
  \item Строится $d'_{S'}(t)$ -- обновление для ребра $S'$ от ребра $S$.
  \item В очередь добавляется событие $\langle S', d'_{S'}(t) \rangle$
  \end{enumerate}
\end{enumerate}
\end{description}



\section{Извлечение района поиска}
